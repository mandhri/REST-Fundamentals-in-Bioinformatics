---
title: 'Case Study: BRCA1 via Ensembl REST'
output: html_document
date: "2025-08-25"
---
# Introduction

This mini-project demonstrates how to use a **REST API** in bioinformatics, using the
[Ensembl REST API](https://rest.ensembl.org/).  
We will practice making requests in **Bash** (with `curl`) and parsing the results in **R**.
The project covers:

We will use R to parse JSON and FASTA results.

```{r libraries, include=FALSE}
library(httr2)
library(jsonlite)
library(dplyr)
library(purrr)
library(readr)
library(glue)
library(listviewer)

```


# Test API Connectivity

Before diving into complex queries, let's verify the API is working and explore what's available.

## Check if the API is alive

The /info/ping endpoint tells us if the Ensembl servers are responding:
We expect to see HTTP/1.1 200 OK if the server is healthy.

```{bash}

# -s       : silent (less noise)
# -D -     : print response headers to stdout ("-")
# -o /dev/null : discard the body (we only care about headers here)
curl -s -D - -o /dev/null "https://rest.ensembl.org/info/ping"

```

# Explore Available Species
Let's see what organisms are available in Ensembl:

What this does: Requests the species list as JSON and saves to species.json.
We then inspect it in R to confirm homo_sapiens is available.

```{bash}

# 'content-type=application/json' tells the API to send JSON back
curl -s "https://rest.ensembl.org/info/species?content-type=application/json" \
  > species.json

```

## Parse in R:

```{r}

sp <- jsonlite::fromJSON("species.json")
length(sp$species)             # how many species are listed?
head(sp$species$name, 10)      # first ten species names

# Find humans specifically
human_info <- sp$species[sp$species$name == "homo_sapiens", ]
cat("Name:", human_info$name, "\n")
cat("Display name:", human_info$display_name, "\n") 
cat("Assembly:", human_info$assembly, "\n")
```

# Lookup a gene by symbol

Given a gene symbol (BRCA1), find its Ensembl gene ID, chromosome, and coordinates.
We add expand=1 to include transcript information as well.

In the below code:

- lookup/symbol → endpoint to look up by gene symbol
- homo_sapiens → species name
- BRCA1 → gene symbol
- expand=1 → include children features (transcripts, exons)

```{bash}

curl -s -H "Accept: application/json" \
"https://rest.ensembl.org/lookup/symbol/homo_sapiens/BRCA1?expand=1" \
> brca1.json
```

## Parse in R:

Gene ID: ENSG00000012048 - This is Ensembl's stable identifier for BRCA1. Gene symbols (like BRCA1) can change, but these IDs remain constant.
Coordinates: Tell us exactly where on chromosome 17 this gene is located.
Strand: Genes can be read in either direction along the chromosome (+ or - strand).
Transcripts: Most genes have multiple "versions" called transcripts, which produce different protein variants.

```{r}

brca1 <- jsonlite::fromJSON("brca1.json", simplifyVector = TRUE)
brca1$id               # Ensembl gene ID
brca1$seq_region_name  # Chromosome
c(brca1$start, brca1$end, brca1$strand)  # Coordinates
length(brca1$Transcript)                 # Number of transcripts


```

# Download genomic sequence (FASTA)

Retrieve the genomic sequence (DNA sequence) of BRCA1 using its Ensembl ID.

- /sequence/id/{id} → fetches sequence by Ensembl ID

- type=genomic → genomic DNA sequence  (including introns and exons)

- Accept: text/x-fasta → return FASTA format

```{bash}

curl -s -H "Accept: text/x-fasta" \
  "https://rest.ensembl.org/sequence/id/ENSG00000012048?type=genomic" \
  > BRCA1_genomic.fasta

```

## Check in R:

FASTA is the standard format for biological sequences:

Line starting with >  → header (contains sequence name and description)
Following lines  → the actual sequence
Sequences are usually broken into lines of 60-80 characters for readability

```{r}

# Read the FASTA file
fa <- readr::read_file("BRCA1_genomic.fasta")

# Show the header and first part of sequence
substr(fa, 1, 200)

# Count nucleotides
sequence_only <- gsub(">[^\n]*\n", "", fa)  # Remove header
sequence_only <- gsub("\n", "", sequence_only)  # Remove line breaks
cat("\nSequence length:", nchar(sequence_only), "nucleotides\n")

# Count each nucleotide
cat("Nucleotide composition:\n")
cat("A:", sum(strsplit(sequence_only, "")[[1]] == "A"), "\n")
cat("T:", sum(strsplit(sequence_only, "")[[1]] == "T"), "\n")
cat("G:", sum(strsplit(sequence_only, "")[[1]] == "G"), "\n")
cat("C:", sum(strsplit(sequence_only, "")[[1]] == "C"), "\n")
```

# Download transcripts and focus on Protein-Coding Sequences

Up until now, we grabbed the BRCA1 gene and downloaded the whole genomic DNA sequence. The genomic sequence includes everything: introns (removed during RNA processing) and exons (kept in the final mRNA). But remember: genes can make different “versions” of RNA, called transcripts. Each transcript is like an alternative recipe for making the protein.

Inside each transcript, there’s a special stretch called the CDS (coding DNA sequence). That’s the part of the DNA that actually codes for the protein. For protein analysis, we usually want just the CDS

1. Pull out the first transcript ID from the BRCA1 record.

```{r}

# Ensure transcript data is available before proceeding
stopifnot(!is.null(brca1$Transcript), length(brca1$Transcript) > 0)
# extract first transcript ID from brca1.json
tx_id <- brca1$Transcript$id[[1]]
tx_id
writeLines(tx_id, "tx_id.txt")
```

2. Use that transcript ID to download its CDS sequence in FASTA format.

```{bash}

TX_ID=$(cat tx_id.txt)
curl -s -H "Accept: text/x-fasta" \
  "https://rest.ensembl.org/sequence/id/${TX_ID}?type=cds" \
  > "${TX_ID}_cds.fasta"

```

## Check in R:

```{r}

cds <- readr::read_file(paste0(tx_id, "_cds.fasta"))
substr(cds, 1, 200)

```

# Compare genomic vs CDS lengths:

Key Insight: The genomic sequence is much longer than the CDS because it includes introns, which are spliced out during mRNA processing.

```{r}

# Read CDS sequence
cds <- readr::read_file(paste0(tx_id, "_cds.fasta"))

# Extract sequence without header/newlines
cds_seq <- gsub(">[^\n]*\n", "", cds)
cds_seq <- gsub("\n", "", cds_seq)

cat("Genomic sequence length:", nchar(sequence_only), "bp\n")
cat("CDS sequence length:", nchar(cds_seq), "bp\n")
cat("Difference:", nchar(sequence_only) - nchar(cds_seq), "bp (mostly introns)\n")

# Show start of CDS
cat("\nFirst 60 nucleotides of CDS:\n")
cat(substr(cds_seq, 1, 60), "\n")

# Translate to amino acids (first 20)
if (nchar(cds_seq) >= 60) {
  codons <- substring(cds_seq, seq(1, 57, 3), seq(3, 59, 3))
  cat("\nFirst 20 codons:", paste(codons, collapse = " "), "\n")
}

```


#  Explore a Chromosomal Region
Let's find all genes near BRCA1 on chromosome 17:

- /overlap/region/{species}/{chr}:{start}-{end} → region query

- feature=gene → only return genes

This 200kb region includes BRCA1 and neighboring genes
feature=gene means we only want genes (not other features like regulatory elements)

```{bash}
curl -s -H "Accept: application/json" \
  "https://rest.ensembl.org/overlap/region/human/17:43000000-43200000?feature=gene" \
  > overlap_chr17.json

```

## Check in R:
This shows you the genomic neighborhood around BRCA1. Gene density varies across the genome - some regions are gene-rich, others are gene-poor.

```{r}
# Load regional gene data
ov <- jsonlite::fromJSON("overlap_chr17.json", simplifyVector = TRUE)

cat("Found", nrow(ov), "genes in this 200kb region\n\n")

# Create a clean table
gene_table <- data.frame(
  symbol = ov$external_name,
  gene_id = ov$gene_id,
  chr = ov$seq_region_name,
  start = ov$start,
  end = ov$end,
  strand = ifelse(ov$strand == 1, "+", "-"),
  length = ov$end - ov$start + 1
)

# Sort by position
gene_table <- gene_table[order(gene_table$start), ]
print(gene_table)

# Find BRCA1 in this list
brca1_row <- which(gene_table$symbol == "BRCA1")
if (length(brca1_row) > 0) {
  cat("\nBRCA1 is gene #", brca1_row, "in this region\n")
}

```

# Batch: multiple symbols → Ensembl IDs → FASTA

Now let's scale up and analyse several cancer-related genes at once:


```{r}
# Define our gene list
symbols <- c("BRCA1", "BRCA2", "TP53", "EGFR", "MYC")
cat("Analyzing genes:", paste(symbols, collapse = ", "), "\n")

# Save for bash processing
writeLines(symbols, "symbols.txt")

```


```{bash}

mkdir -p data

# Loop through each gene symbol
while read SYM; do
  curl -s -H "Accept: application/json" \
    "https://rest.ensembl.org/lookup/symbol/homo_sapiens/${SYM}?expand=0" \
    > "data/${SYM}.json"
# sleep 0.2 is a bash command that pauses the script for 0.2 seconds before continuing to the next line. APIs have rate limits where they accept and handle maximum requests per second/minute.Without sleep: 100 requests in ~2 seconds (might fail) whereas With sleep 0.2: 100 requests in ~20 seconds (reliable) 
sleep 0.2
done < symbols.txt

```


## Compile results into a summary table: 

```{r}

# Process all the JSON files we created
files <- list.files("/home/mandhri/REST-Fundamentals-in-Bioinformatics/data/", pattern = "\\.json$", full.names = TRUE)

rows <- lapply(files, function(f){
  tryCatch({
    x <- jsonlite::fromJSON(f, simplifyVector = TRUE)
    data.frame(
      symbol = sub("\\.json$", "", basename(f)),
      gene_id = x$id,
      chr = x$seq_region_name,
      start = x$start,
      end = x$end,
      strand = ifelse(x$strand == 1, "+", "-"),
      gene_length = x$end - x$start + 1,
      description = ifelse(is.null(x$description), "No description", x$description)
    )
  }, error = function(e) {
    cat("Error processing", f, ":", e$message, "\n")
    return(NULL)
  })
})

# Combine all results
tbl <- do.call(rbind, rows[!sapply(rows, is.null)])

# Sort by chromosome and position
tbl <- tbl[order(tbl$chr, tbl$start), ]
print(tbl)

# Save results
write_csv(tbl, "genes_coordinates.csv")
cat("\nResults saved to genes_coordinates.csv\n")
```


## Visualise gene locations:

```{r}

# Simple visualisation of gene locations
library(ggplot2)

# Create a plot showing gene positions
p <- ggplot(tbl, aes(x = start/1e6, y = factor(chr, levels = unique(chr)), 
                     color = symbol)) +
  geom_point(size = 3) +
  labs(
    title = "Chromosomal Locations of Cancer Genes",
    x = "Position (Mb)",
    y = "Chromosome",
    color = "Gene"
  ) +
  theme_minimal()

print(p)
```


# Download genomic FASTA for each Ensembl ID (Batch download genomic FASTA)

Let's download genomic sequences for all our genes:

```{bash}

# Extract gene IDs from our CSV file (skip header)
awk -F, 'NR>1 {print $2}' genes_coordinates.csv > gene_ids.txt

mkdir -p fasta_genomic
# Download each sequence
while read GID; do
  curl -s -H "Accept: text/x-fasta" \
    "https://rest.ensembl.org/sequence/id/${GID}?type=genomic" \
    > "fasta_genomic/${GID}_genomic.fasta"
  sleep 0.2
done < gene_ids.txt


```

Analyse sequence properties:


```{r}

# Analyse all downloaded sequences
fasta_files <- list.files("/home/mandhri/REST-Fundamentals-in-Bioinformatics/fasta_genomic", pattern = "\\.fasta$", full.names = TRUE)

seq_analysis <- lapply(fasta_files, function(f) {
  # Read sequence
  fa <- readr::read_file(f)
  seq_only <- gsub(">[^\n]*\n", "", fa)
  seq_only <- gsub("\n", "", seq_only)
  
  # Extract gene ID from filename
  gene_id <- sub("_genomic\\.fasta$", "", basename(f))
  
  # Calculate properties
  data.frame(
    gene_id = gene_id,
    length = nchar(seq_only),
    gc_content = (sum(strsplit(seq_only, "")[[1]] %in% c("G", "C")) / nchar(seq_only)) * 100
  )
})

seq_stats <- do.call(rbind, seq_analysis)

# Merge with gene symbols
final_table <- merge(tbl[, c("symbol", "gene_id")], seq_stats, by = "gene_id")
print(final_table)

# Summary statistics
cat("\nSequence Statistics:\n")
cat("Average gene length:", round(mean(final_table$length)), "bp\n")
cat("Average GC content:", round(mean(final_table$gc_content), 1), "%\n")

```


```{r}

sessionInfo()

```

